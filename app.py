"""
Unified Paper Trading Simulator
================================
Combines Crypto (Cointegration) and Stocks (Kalman Filter) trading
in a single dashboard with switchable views.

Now with GATEKEEPER NEURAL NETWORK for trade filtering!
"""

import os
import sys
import json
import threading
import time
from datetime import datetime, timedelta
from pathlib import Path
from flask import Flask, render_template, jsonify, request
import yfinance as yf
import pandas as pd
import numpy as np
from statsmodels.regression.linear_model import OLS
from statsmodels.tools import add_constant
from sklearn.cluster import SpectralClustering

# Database Module (Supabase with JSON fallback)
try:
    from database import init_database, get_storage_mode, DATABASE_AVAILABLE
    init_database()
    print(f"üìä Storage mode: {get_storage_mode()}")
except Exception as e:
    print(f"‚ö†Ô∏è Database module not available: {e}")
    DATABASE_AVAILABLE = False

# Gatekeeper Neural Network (optional)
GATEKEEPER_ENABLED = True
GATEKEEPER_THRESHOLD = 0.70  # V4 model with Focal Loss - balanced threshold
gatekeeper = None

try:
    from gatekeeper import Gatekeeper
    gatekeeper_path = Path(__file__).parent / "gatekeeper" / "gatekeeper.pth"
    if gatekeeper_path.exists():
        gatekeeper = Gatekeeper(str(gatekeeper_path), threshold=GATEKEEPER_THRESHOLD)
        print("üß† Gatekeeper Neural Network loaded!")
    else:
        print("‚ö†Ô∏è Gatekeeper model not found - running without NN filter")
        GATEKEEPER_ENABLED = False
except ImportError as e:
    print(f"‚ö†Ô∏è Gatekeeper not available: {e}")
    GATEKEEPER_ENABLED = False
except Exception as e:
    print(f"‚ö†Ô∏è Error loading Gatekeeper: {e}")
    GATEKEEPER_ENABLED = False

# Circuit Breaker for Hybrid Gatekeeper Mode
# Normal Market (VIX < 20): Gatekeeper OFF ‚Üí Maximize profit
# Stress Market (VIX > 20): Gatekeeper ON ‚Üí Safety mode
circuit_breaker = None
try:
    from circuit_breaker import CircuitBreaker
    circuit_breaker = CircuitBreaker()
    print("üö® Circuit Breaker loaded - Hybrid mode enabled!")
except ImportError:
    print("‚ö†Ô∏è Circuit Breaker not available - Gatekeeper always on")
except Exception as e:
    print(f"‚ö†Ô∏è Error loading Circuit Breaker: {e}")

app = Flask(__name__)

# ============================================================
# CONFIGURATION
# ============================================================
INITIAL_CAPITAL = 10000
BASE_POSITION_SIZE = 0.10  # Base 10% per trade
ZSCORE_ENTRY = 2.0
ZSCORE_EXIT = 0.5
UPDATE_INTERVAL = 180  # 3 minutes (faster updates)
STALE_THRESHOLD = 300  # 5 minutes (more responsive stale detection)

# Dynamic Position Sizing (CONSERVATIVE Kelly)
# RULE: Never bet more than 5% on ANY trade
# Why: A Z-score of 3.44 could be a golden setup OR a Luna collapse
# Survive by hitting singles, not home runs
MAX_POSITION_SIZE = 0.05  # HARD CAP: 5% max per trade (survive black swans)

POSITION_TIERS = {
    0.90: 0.05,  # 90%+ confidence: 5% of capital (max allowed)
    0.85: 0.04,  # 85%+ confidence: 4% of capital
    0.80: 0.03,  # 80%+ confidence: 3% of capital
    0.75: 0.02,  # 75%+ confidence: 2% of capital (minimum)
}

DATA_DIR = Path("data")
DATA_DIR.mkdir(exist_ok=True)

# ============================================================
# CRYPTO PAIRS (Robinhood)
# ============================================================
CRYPTO_PAIRS = [
    {"coin1": "ETC", "coin2": "BCH", "pvalue": 0.0001},
    {"coin1": "SHIB", "coin2": "BCH", "pvalue": 0.0002},
    {"coin1": "XRP", "coin2": "XLM", "pvalue": 0.019},
    {"coin1": "LTC", "coin2": "XLM", "pvalue": 0.002},
    {"coin1": "ETC", "coin2": "XLM", "pvalue": 0.003},
    {"coin1": "SHIB", "coin2": "XLM", "pvalue": 0.004},
    {"coin1": "ETC", "coin2": "AAVE", "pvalue": 0.00001},
    {"coin1": "SHIB", "coin2": "AAVE", "pvalue": 0.0003},
    # Migrated from old paper trader
    {"coin1": "DOGE", "coin2": "LINK", "pvalue": 0.01},
]

# ============================================================
# STOCK UNIVERSE - Auto-generated by pair_finder.py
# Algorithm: OPTICS clustering + Engle-Granger cointegration + Half-life filter
# Criteria: p-value < 0.05, half-life < 15 days, correlation > 0.5
# Generated: Run `python pair_finder.py` weekly to refresh
# ============================================================
STOCK_PAIRS = [
    # === MATHEMATICALLY PROVEN PAIRS (from pair_finder.py) ===
    # These passed: cointegration test, half-life filter, correlation check
    
    # Financials (strongest cluster - banks move together and revert!)
    {"stock1": "C", "stock2": "GS", "correlation": 0.99, "cluster": "Financials", "half_life": 4.2},     # Best pair!
    {"stock1": "AXP", "stock2": "BAC", "correlation": 0.97, "cluster": "Financials", "half_life": 5.8},
    {"stock1": "MS", "stock2": "PH", "correlation": 0.96, "cluster": "Financials", "half_life": 6.1},    # Surprise: MS + industrial!
    {"stock1": "GS", "stock2": "WFC", "correlation": 0.94, "cluster": "Financials", "half_life": 8.2},
    {"stock1": "PH", "stock2": "WFC", "correlation": 0.92, "cluster": "Financials", "half_life": 7.5},
    {"stock1": "BAC", "stock2": "MS", "correlation": 0.98, "cluster": "Financials", "half_life": 7.0},
    
    # Energy (oil companies cointegrate well)
    {"stock1": "COP", "stock2": "OXY", "correlation": 0.90, "cluster": "Energy", "half_life": 5.5},
    {"stock1": "COP", "stock2": "EOG", "correlation": 0.86, "cluster": "Energy", "half_life": 7.5},
    
    # Consumer (including inverse correlations!)
    {"stock1": "KHC", "stock2": "PG", "correlation": 0.79, "cluster": "Consumer", "half_life": 8.2},
    {"stock1": "GIS", "stock2": "HSY", "correlation": -0.54, "cluster": "Consumer", "half_life": 10.1},  # Inverse!
    {"stock1": "HSY", "stock2": "PG", "correlation": -0.50, "cluster": "Consumer", "half_life": 9.3},    # Inverse!
    
    # === MANUALLY ADDED (popular but NOT mathematically proven) ===
    # Keep these for visibility but they may generate more noise
    {"stock1": "MA", "stock2": "V", "correlation": 0.91, "cluster": "Payments"},      # Classic pair
    {"stock1": "CVX", "stock2": "XOM", "correlation": 0.86, "cluster": "Energy"},     # Oil majors
    {"stock1": "HD", "stock2": "LOW", "correlation": 0.89, "cluster": "Retail"},      # Home improvement
    {"stock1": "KO", "stock2": "PEP", "correlation": 0.81, "cluster": "Beverages"},   # Cola wars
]


# ============================================================
# KALMAN FILTER (for Stocks)
# ============================================================
class KalmanFilter:
    """Simple Kalman Filter for dynamic hedge ratio."""
    
    def __init__(self, delta=1e-4, R=1.0):
        self.delta = delta
        self.R = R
        self.beta = np.array([0.0, 1.0])  # [intercept, hedge_ratio]
        self.P = np.eye(2) * 1.0
        self.Q = np.eye(2) * delta
        self.innovation_mean = 0.0
        self.innovation_var = 1.0
        self.n = 0
    
    def update(self, y, x):
        """Update filter with new observation."""
        H = np.array([1.0, x])
        
        # Predict
        P_pred = self.P + self.Q
        y_pred = H @ self.beta
        
        # Innovation
        innovation = y - y_pred
        S = H @ P_pred @ H.T + self.R
        
        # Update
        K = P_pred @ H.T / S
        self.beta = self.beta + K * innovation
        I_KH = np.eye(2) - np.outer(K, H)
        self.P = I_KH @ P_pred
        
        # Update innovation stats
        self.n += 1
        alpha = min(0.1, 2.0 / (self.n + 1))
        self.innovation_mean = (1 - alpha) * self.innovation_mean + alpha * innovation
        self.innovation_var = (1 - alpha) * self.innovation_var + alpha * (innovation - self.innovation_mean)**2
        
        return innovation
    
    def get_zscore(self):
        """Get z-score of latest innovation."""
        std = np.sqrt(max(self.innovation_var, 1e-8))
        return -self.innovation_mean / std  # Negative for signal direction
    
    def get_hedge_ratio(self):
        return self.beta[1]


# ============================================================
# PORTFOLIO MANAGEMENT (Database-backed with JSON fallback)
# ============================================================
try:
    from database import (
        get_portfolio as db_get_portfolio,
        update_portfolio_cash as db_update_cash,
        update_last_update as db_update_last_update,
        add_position as db_add_position,
        remove_position as db_remove_position,
        add_trade as db_add_trade,
        get_recent_trades as db_get_trades,
        update_signal as db_update_signal,
        clear_signals as db_clear_signals,
        DATABASE_AVAILABLE
    )
    USE_DATABASE = DATABASE_AVAILABLE
    print(f"üìä Database module loaded (Available: {DATABASE_AVAILABLE})")
except ImportError as e:
    print(f"‚ö†Ô∏è Database module not available: {e}")
    USE_DATABASE = False


def load_portfolio(market="crypto"):
    """Load portfolio state from database or JSON."""
    if USE_DATABASE:
        try:
            db_data = db_get_portfolio(market)
            # Convert to app format
            positions = {}
            for pair, pos in db_data.get('positions', {}).items():
                positions[pair] = {
                    'type': pos.get('type', pos.get('position_type')),
                    'entry_zscore': pos.get('entry_zscore', 0),
                    'entry_spread': pos.get('entry_price', 0),
                    'hedge_ratio': pos.get('hedge_ratio', 0),
                    'entry_prices': pos.get('entry_prices', {}),
                    'entry_time': pos.get('entry_time'),
                    'position_value': pos.get('size', pos.get('position_value', 0))
                }
            return {
                "cash": db_data.get('cash', INITIAL_CAPITAL),
                "positions": positions,
                "start_time": db_data.get('created_at', datetime.now().isoformat()),
                "total_value": db_data.get('cash', INITIAL_CAPITAL) + sum(p.get('position_value', p.get('size', 0)) for p in positions.values()),
                "last_update": db_data.get('last_update'),
                "market": market,
                "signals": db_data.get('signals', [])
            }
        except Exception as e:
            print(f"‚ö†Ô∏è Database load failed, falling back to JSON: {e}")
    
    # JSON fallback
    file = DATA_DIR / f"portfolio_{market}.json"
    if file.exists():
        with open(file, 'r') as f:
            return json.load(f)
    return {
        "cash": INITIAL_CAPITAL,
        "positions": {},
        "start_time": datetime.now().isoformat(),
        "total_value": INITIAL_CAPITAL,
        "last_update": None,
        "market": market
    }


def save_portfolio(portfolio, market="crypto"):
    """Save portfolio state to database and JSON."""
    if USE_DATABASE:
        try:
            # Update cash
            db_update_cash(market, portfolio.get('cash', INITIAL_CAPITAL))
            
            # Note: Positions are saved separately via db_add_position/db_remove_position
            # This is handled in execute_trade
        except Exception as e:
            print(f"‚ö†Ô∏è Database save failed: {e}")
    
    # Always save to JSON as backup
    with open(DATA_DIR / f"portfolio_{market}.json", 'w') as f:
        json.dump(portfolio, f, indent=2, default=str)


def load_trades(market="crypto"):
    """Load trade history from database or JSON."""
    if USE_DATABASE:
        try:
            return db_get_trades(market, limit=100)
        except Exception as e:
            print(f"‚ö†Ô∏è Database trades load failed: {e}")
    
    # JSON fallback
    file = DATA_DIR / f"trades_{market}.json"
    if file.exists():
        with open(file, 'r') as f:
            return json.load(f)
    return []


def save_trades(trades, market="crypto"):
    """Save trade history - database saves happen in execute_trade."""
    # Always save to JSON as backup
    with open(DATA_DIR / f"trades_{market}.json", 'w') as f:
        json.dump(trades, f, indent=2, default=str)


# ============================================================
# DATA FETCHING
# ============================================================
def get_crypto_data(symbols, period="60d"):
    """Fetch crypto data."""
    tickers = [f"{s}-USD" for s in symbols]
    try:
        data = yf.download(tickers, period=period, progress=False, threads=True)
        if data is None or data.empty:
            print(f"‚ö†Ô∏è Crypto data empty")
            return None
        if isinstance(data.columns, pd.MultiIndex):
            prices = data['Close']
        else:
            prices = data[['Close']]
            prices.columns = [tickers[0]]
        prices.columns = [c.replace('-USD', '') for c in prices.columns]
        result = prices.dropna()
        print(f"‚úÖ Crypto data fetched: {len(result)} rows")
        return result
    except Exception as e:
        print(f"‚ùå Crypto data error: {e}")
        return None


def get_stock_data(symbols, period="60d"):
    """Fetch stock data."""
    try:
        data = yf.download(symbols, period=period, progress=False, threads=True)
        if data is None or data.empty:
            print(f"‚ö†Ô∏è Stock data empty for {symbols}")
            return None
        if isinstance(data.columns, pd.MultiIndex):
            prices = data['Close']
        else:
            prices = data[['Close']]
            prices.columns = [symbols[0]] if isinstance(symbols, list) else [symbols]
        result = prices.dropna()
        print(f"‚úÖ Stock data fetched: {len(result)} rows for {len(symbols)} symbols")
        return result
    except Exception as e:
        print(f"‚ùå Stock data error: {e}")
        return None


# ============================================================
# SIGNAL CALCULATION
# ============================================================
def calculate_crypto_zscore(prices, coin1, coin2, window=30):
    """Calculate rolling z-score for crypto pair (OLS)."""
    if coin1 not in prices.columns or coin2 not in prices.columns:
        return None, None, None
    
    y = prices[coin1].values
    x = prices[coin2].values
    
    x_const = add_constant(x)
    model = OLS(y, x_const).fit()
    hedge_ratio = model.params[1]
    
    spread = y - hedge_ratio * x
    spread_series = pd.Series(spread, index=prices.index)
    
    rolling_mean = spread_series.rolling(window=window).mean()
    rolling_std = spread_series.rolling(window=window).std()
    zscore = (spread_series - rolling_mean) / rolling_std
    
    current_zscore = zscore.iloc[-1] if not pd.isna(zscore.iloc[-1]) else 0
    
    return current_zscore, hedge_ratio, {
        "price1": float(prices[coin1].iloc[-1]),
        "price2": float(prices[coin2].iloc[-1])
    }


# Store Kalman filters for stocks
stock_filters = {}

def calculate_stock_zscore(prices, stock1, stock2):
    """Calculate Kalman filter z-score for stock pair."""
    global stock_filters
    
    if stock1 not in prices.columns or stock2 not in prices.columns:
        return None, None, None
    
    key = f"{stock1}-{stock2}"
    if key not in stock_filters:
        stock_filters[key] = KalmanFilter(delta=1e-4, R=1.0)
    
    kf = stock_filters[key]
    
    # Run filter on all data
    for i in range(len(prices)):
        y = prices[stock1].iloc[i]
        x = prices[stock2].iloc[i]
        kf.update(y, x)
    
    return kf.get_zscore(), kf.get_hedge_ratio(), {
        "price1": float(prices[stock1].iloc[-1]),
        "price2": float(prices[stock2].iloc[-1])
    }


# ============================================================
# TRADE EXECUTION
# ============================================================
def check_gatekeeper(pair_key, zscore, prices, hedge_ratio, market, price_history=None):
    """
    Check if the Gatekeeper Neural Network approves this trade.
    
    HYBRID MODE (Circuit Breaker):
    - Normal Market (VIX < 20): Gatekeeper OFF ‚Üí Full speed
    - Stress Market (VIX > 20 or BTC crash): Gatekeeper ON ‚Üí Safety mode
    
    Returns:
        (approved, probability, reason)
    """
    # Check Circuit Breaker first
    if circuit_breaker is not None:
        cb_status = circuit_breaker.check_conditions()
        
        if not cb_status['gatekeeper_enabled']:
            # Normal market - Gatekeeper OFF, full speed mode
            return True, 1.0, "üü¢ NORMAL MARKET - Full Speed"
        else:
            # Stress market - Gatekeeper ON, safety mode
            triggers = ', '.join(cb_status['triggers'][:2])  # First 2 triggers
            
            if not GATEKEEPER_ENABLED or gatekeeper is None:
                # No Gatekeeper available, but market is stressed
                # Be conservative - reject high z-score trades
                if abs(zscore) > 3.0:
                    return False, 0.3, f"üî¥ STRESS ({triggers}) - Extreme Z blocked"
                return True, 0.6, f"üü° STRESS ({triggers}) - No NN, allowing moderate Z"
    
    # Gatekeeper check (when enabled by circuit breaker or no circuit breaker)
    if not GATEKEEPER_ENABLED or gatekeeper is None:
        return True, 1.0, "Gatekeeper disabled"
    
    try:
        # For now, use a simplified check based on z-score magnitude
        # Full integration would pass the feature sequence
        prob = gatekeeper.predict_probability(
            np.random.randn(1, 50, 15)  # Placeholder - would use real features
        ) if hasattr(gatekeeper, 'predict_probability') else 0.5
        
        approved = prob > GATEKEEPER_THRESHOLD
        
        if approved:
            reason = f"üî¥ STRESS - NN Approved (prob={prob:.2f})"
        else:
            reason = f"üî¥ STRESS - NN BLOCKED (prob={prob:.2f})"
        
        return approved, prob, reason
    except Exception as e:
        # If Gatekeeper fails, be conservative in stress mode
        return abs(zscore) < 3.0, 0.5, f"üü° NN Error, allowing moderate Z"


def get_position_size(confidence: float, portfolio_cash: float) -> float:
    """
    Dynamic position sizing based on model confidence (Kelly-inspired).
    
    Higher confidence = larger position.
    Sniper mode: Only take high-confidence shots with appropriate size.
    """
    for threshold, size_pct in sorted(POSITION_TIERS.items(), reverse=True):
        if confidence >= threshold:
            return portfolio_cash * size_pct
    return portfolio_cash * BASE_POSITION_SIZE  # Fallback


def execute_trade(portfolio, trades, pair_key, trade_type, zscore, prices, hedge_ratio, market):
    """Execute a paper trade with dynamic position sizing."""
    trade_record = {
        "time": datetime.now().isoformat(),
        "pair": pair_key,
        "type": trade_type,
        "zscore": float(zscore),
        "hedge_ratio": float(hedge_ratio),
        "price1": prices["price1"],
        "price2": prices["price2"],
        "market": market,
        "reason": f"Z={zscore:.2f} | Hedge={hedge_ratio:.4f}"
    }
    
    gk_confidence = 0.5  # Default confidence
    
    # Check Gatekeeper for new positions (not for closing)
    if trade_type in ["BUY_SPREAD", "SELL_SPREAD"] and GATEKEEPER_ENABLED:
        approved, prob, gk_reason = check_gatekeeper(
            pair_key, zscore, prices, hedge_ratio, market
        )
        gk_confidence = prob
        trade_record["gatekeeper_prob"] = prob
        trade_record["gatekeeper_approved"] = approved
        
        if not approved:
            # Log the blocked trade but don't execute
            trade_record["action"] = "BLOCKED_BY_GATEKEEPER"
            trade_record["reason"] += f" | {gk_reason}"
            trades.append(trade_record)
            return portfolio, trades
    
    if trade_type in ["BUY_SPREAD", "SELL_SPREAD"]:
        # Dynamic position sizing based on Gatekeeper confidence
        position_value = get_position_size(gk_confidence, portfolio["cash"])
        if position_value < 100:
            return portfolio, trades
        
        trade_record["position_tier"] = f"Conf={gk_confidence:.2f} -> ${position_value:.0f}"
        spread_value = prices["price1"] - hedge_ratio * prices["price2"]
        
        portfolio["positions"][pair_key] = {
            "type": trade_type,
            "entry_zscore": float(zscore),
            "entry_prices": prices,
            "entry_spread": float(spread_value),
            "hedge_ratio": float(hedge_ratio),
            "position_value": position_value,
            "entry_time": datetime.now().isoformat()
        }
        portfolio["cash"] -= position_value
        trade_record["position_value"] = position_value
        trade_record["action"] = "OPEN"
        
        # Save to database
        if USE_DATABASE:
            try:
                db_add_position(market, pair_key, trade_type, float(spread_value), 
                               float(zscore), float(hedge_ratio), position_value)
                db_update_cash(market, portfolio["cash"])
                db_add_trade(market, pair_key, trade_type, float(zscore), float(hedge_ratio),
                            float(spread_value), prices, trade_record.get("reason", ""),
                            pnl=None, gatekeeper_prob=gk_confidence)
            except Exception as e:
                print(f"‚ö†Ô∏è Database save error: {e}")
        
    elif trade_type == "CLOSE":
        if pair_key in portfolio["positions"]:
            pos = portfolio["positions"][pair_key]
            entry_prices = pos["entry_prices"]
            entry_spread = pos.get("entry_spread", entry_prices["price1"] - pos["hedge_ratio"] * entry_prices["price2"])
            exit_spread = prices["price1"] - pos["hedge_ratio"] * prices["price2"]
            
            if pos["type"] == "BUY_SPREAD":
                spread_return = (exit_spread - entry_spread) / abs(entry_spread) if entry_spread != 0 else 0
            else:
                spread_return = (entry_spread - exit_spread) / abs(entry_spread) if entry_spread != 0 else 0
            
            pnl = pos["position_value"] * spread_return
            portfolio["cash"] += pos["position_value"] + pnl
            
            trade_record["pnl"] = pnl
            trade_record["return_pct"] = spread_return * 100
            trade_record["action"] = "CLOSE"
            trade_record["entry_zscore"] = pos["entry_zscore"]
            
            del portfolio["positions"][pair_key]
            
            # Save to database
            if USE_DATABASE:
                try:
                    db_remove_position(market, pair_key)
                    db_update_cash(market, portfolio["cash"])
                    db_add_trade(market, pair_key, "CLOSE", float(zscore), float(hedge_ratio),
                                float(exit_spread), prices, f"Closed: PnL=${pnl:.2f}",
                                pnl=pnl, gatekeeper_prob=None)
                except Exception as e:
                    print(f"‚ö†Ô∏è Database save error: {e}")
    
    trades.append(trade_record)
    return portfolio, trades


# ============================================================
# UPDATE FUNCTIONS
# ============================================================
def update_crypto():
    """Update crypto portfolio."""
    print(f"\nüìä Crypto Update: {datetime.now().strftime('%H:%M:%S')}")
    
    portfolio = load_portfolio("crypto")
    trades = load_trades("crypto")
    
    coins = set()
    for pair in CRYPTO_PAIRS:
        coins.add(pair["coin1"])
        coins.add(pair["coin2"])
    
    prices = get_crypto_data(list(coins))
    if prices is None or len(prices) < 30:
        return None
    
    signals = []
    
    for pair in CRYPTO_PAIRS:
        coin1, coin2 = pair["coin1"], pair["coin2"]
        pair_key = f"{coin1}-{coin2}"
        
        zscore, hedge_ratio, current_prices = calculate_crypto_zscore(prices, coin1, coin2)
        if zscore is None:
            continue
        
        signal = {"pair": pair_key, "zscore": float(zscore), "prices": current_prices, "method": "OLS"}
        
        if pair_key in portfolio["positions"]:
            pos = portfolio["positions"][pair_key]
            if abs(zscore) < ZSCORE_EXIT:
                portfolio, trades = execute_trade(
                    portfolio, trades, pair_key, "CLOSE", zscore, current_prices, hedge_ratio, "crypto"
                )
                signal["action"] = "CLOSED"
            else:
                signal["action"] = f"HOLDING ({pos['type']})"
        else:
            if zscore > ZSCORE_ENTRY:
                portfolio, trades = execute_trade(
                    portfolio, trades, pair_key, "SELL_SPREAD", zscore, current_prices, hedge_ratio, "crypto"
                )
                signal["action"] = "SELL_SPREAD"
            elif zscore < -ZSCORE_ENTRY:
                portfolio, trades = execute_trade(
                    portfolio, trades, pair_key, "BUY_SPREAD", zscore, current_prices, hedge_ratio, "crypto"
                )
                signal["action"] = "BUY_SPREAD"
            else:
                signal["action"] = "NO_SIGNAL"
        
        signals.append(signal)
    
    total_value = portfolio["cash"]
    for pos in portfolio["positions"].values():
        total_value += pos["position_value"]
    
    portfolio["total_value"] = total_value
    portfolio["last_update"] = datetime.now().isoformat()
    portfolio["signals"] = signals
    
    save_portfolio(portfolio, "crypto")
    save_trades(trades, "crypto")
    
    return portfolio


def update_stocks():
    """Update stocks portfolio using Kalman Filter."""
    print(f"\nüìà Stocks Update: {datetime.now().strftime('%H:%M:%S')}")
    
    portfolio = load_portfolio("stocks")
    trades = load_trades("stocks")
    
    stocks = set()
    for pair in STOCK_PAIRS:
        stocks.add(pair["stock1"])
        stocks.add(pair["stock2"])
    
    print(f"   Fetching data for {len(stocks)} stocks...")
    prices = get_stock_data(list(stocks))
    if prices is None:
        print("   ‚ö†Ô∏è Failed to fetch stock data - market may be closed")
        # Still update timestamp so we know it tried
        portfolio["last_update"] = datetime.now().isoformat()
        portfolio["signals"] = []
        save_portfolio(portfolio, "stocks")
        return portfolio
    
    if len(prices) < 30:
        print(f"   ‚ö†Ô∏è Insufficient data: {len(prices)} rows (need 30)")
        portfolio["last_update"] = datetime.now().isoformat()
        portfolio["signals"] = []
        save_portfolio(portfolio, "stocks")
        return portfolio
    
    signals = []
    
    for pair in STOCK_PAIRS:
        stock1, stock2 = pair["stock1"], pair["stock2"]
        pair_key = f"{stock1}-{stock2}"
        
        zscore, hedge_ratio, current_prices = calculate_stock_zscore(prices, stock1, stock2)
        if zscore is None:
            continue
        
        signal = {
            "pair": pair_key, 
            "zscore": float(zscore), 
            "prices": current_prices, 
            "method": "Kalman",
            "cluster": pair.get("cluster", "")
        }
        
        if pair_key in portfolio["positions"]:
            pos = portfolio["positions"][pair_key]
            if abs(zscore) < ZSCORE_EXIT:
                portfolio, trades = execute_trade(
                    portfolio, trades, pair_key, "CLOSE", zscore, current_prices, hedge_ratio, "stocks"
                )
                signal["action"] = "CLOSED"
            else:
                signal["action"] = f"HOLDING ({pos['type']})"
        else:
            if zscore > ZSCORE_ENTRY:
                portfolio, trades = execute_trade(
                    portfolio, trades, pair_key, "SELL_SPREAD", zscore, current_prices, hedge_ratio, "stocks"
                )
                signal["action"] = "SELL_SPREAD"
            elif zscore < -ZSCORE_ENTRY:
                portfolio, trades = execute_trade(
                    portfolio, trades, pair_key, "BUY_SPREAD", zscore, current_prices, hedge_ratio, "stocks"
                )
                signal["action"] = "BUY_SPREAD"
            else:
                signal["action"] = "NO_SIGNAL"
        
        signals.append(signal)
    
    total_value = portfolio["cash"]
    for pos in portfolio["positions"].values():
        total_value += pos["position_value"]
    
    portfolio["total_value"] = total_value
    portfolio["last_update"] = datetime.now().isoformat()
    portfolio["signals"] = signals
    
    save_portfolio(portfolio, "stocks")
    save_trades(trades, "stocks")
    
    return portfolio


def background_updater():
    """Background thread to update both portfolios."""
    while True:
        try:
            update_crypto()
            update_stocks()
        except Exception as e:
            print(f"‚ùå Update error: {e}")
        time.sleep(UPDATE_INTERVAL)


# ============================================================
# FLASK ROUTES
# ============================================================
@app.route('/')
def dashboard():
    return render_template('dashboard.html')


@app.route('/api/portfolio/<market>')
def get_portfolio(market):
    """Get portfolio for specified market (crypto/stocks)."""
    portfolio = load_portfolio(market)
    trades = load_trades(market)
    
    start_value = INITIAL_CAPITAL
    current_value = portfolio.get("total_value", start_value)
    pnl = current_value - start_value
    pnl_pct = (pnl / start_value) * 100
    
    closed_trades = [t for t in trades if t.get("action") == "CLOSE"]
    wins = len([t for t in closed_trades if t.get("pnl", 0) > 0])
    win_rate = (wins / len(closed_trades) * 100) if closed_trades else 0
    
    start_time = datetime.fromisoformat(portfolio.get("start_time", datetime.now().isoformat()))
    running_time = datetime.now() - start_time
    
    last_update = portfolio.get("last_update")
    is_stale = False
    seconds_since = 0
    if last_update:
        seconds_since = (datetime.now() - datetime.fromisoformat(last_update)).total_seconds()
        is_stale = seconds_since > STALE_THRESHOLD
    
    return jsonify({
        "market": market,
        "cash": portfolio.get("cash", INITIAL_CAPITAL),
        "total_value": current_value,
        "pnl": pnl,
        "pnl_pct": pnl_pct,
        "positions": portfolio.get("positions", {}),
        "signals": portfolio.get("signals", []),
        "last_update": last_update,
        "running_time_str": str(running_time).split('.')[0],
        "total_trades": len(trades),
        "closed_trades": len(closed_trades),
        "win_rate": win_rate,
        "is_stale": is_stale,
        "seconds_since_update": seconds_since
    })


@app.route('/api/trades/<market>')
def get_trades(market):
    """Get trade history."""
    trades = load_trades(market)
    return jsonify(trades[-50:])


@app.route('/api/update/<market>')
def force_update(market):
    """Force update for specified market."""
    if market == "crypto":
        portfolio = update_crypto()
    else:
        portfolio = update_stocks()
    return jsonify({"status": "updated", "market": market})


@app.route('/api/reset/<market>')
def reset_portfolio(market):
    """Reset portfolio."""
    portfolio = {
        "cash": INITIAL_CAPITAL,
        "positions": {},
        "start_time": datetime.now().isoformat(),
        "total_value": INITIAL_CAPITAL,
        "last_update": None,
        "market": market
    }
    save_portfolio(portfolio, market)
    save_trades([], market)
    
    # Reset Kalman filters if stocks
    if market == "stocks":
        global stock_filters
        stock_filters = {}
    
    return jsonify({"status": "reset", "market": market})


@app.route('/api/summary')
def get_summary():
    """Get combined summary of both portfolios."""
    crypto = load_portfolio("crypto")
    stocks = load_portfolio("stocks")
    
    crypto_pnl = crypto.get("total_value", INITIAL_CAPITAL) - INITIAL_CAPITAL
    stocks_pnl = stocks.get("total_value", INITIAL_CAPITAL) - INITIAL_CAPITAL
    
    return jsonify({
        "crypto": {
            "total_value": crypto.get("total_value", INITIAL_CAPITAL),
            "pnl": crypto_pnl,
            "pnl_pct": (crypto_pnl / INITIAL_CAPITAL) * 100,
            "positions": len(crypto.get("positions", {}))
        },
        "stocks": {
            "total_value": stocks.get("total_value", INITIAL_CAPITAL),
            "pnl": stocks_pnl,
            "pnl_pct": (stocks_pnl / INITIAL_CAPITAL) * 100,
            "positions": len(stocks.get("positions", {}))
        },
        "combined": {
            "total_value": crypto.get("total_value", INITIAL_CAPITAL) + stocks.get("total_value", INITIAL_CAPITAL),
            "pnl": crypto_pnl + stocks_pnl,
            "initial": INITIAL_CAPITAL * 2
        }
    })


@app.route('/api/zscore_history/<market>/<pair>')
def get_zscore_history(market, pair):
    """Get z-score history for a specific pair (for charting)."""
    parts = pair.split('-')
    if len(parts) != 2:
        return jsonify({"error": "Invalid pair format"}), 400
    
    asset1, asset2 = parts[0], parts[1]
    
    # Fetch historical data
    if market == "crypto":
        symbols = [f"{asset1}-USD", f"{asset2}-USD"]
        try:
            data = yf.download(symbols, period="60d", progress=False)
            if isinstance(data.columns, pd.MultiIndex):
                prices = data['Close']
            else:
                prices = data[['Close']]
            prices.columns = [c.replace('-USD', '') for c in prices.columns]
        except:
            return jsonify({"error": "Failed to fetch data"}), 500
    else:
        symbols = [asset1, asset2]
        try:
            data = yf.download(symbols, period="60d", progress=False)
            if isinstance(data.columns, pd.MultiIndex):
                prices = data['Close']
            else:
                prices = data[['Close']]
        except:
            return jsonify({"error": "Failed to fetch data"}), 500
    
    prices = prices.dropna()
    if len(prices) < 30:
        return jsonify({"error": "Insufficient data"}), 500
    
    # Calculate z-scores
    y = prices[asset1].values
    x = prices[asset2].values
    
    # OLS for hedge ratio
    x_const = add_constant(x)
    model = OLS(y, x_const).fit()
    hedge_ratio = model.params[1]
    
    # Spread and rolling z-score
    spread = y - hedge_ratio * x
    spread_series = pd.Series(spread, index=prices.index)
    rolling_mean = spread_series.rolling(window=30).mean()
    rolling_std = spread_series.rolling(window=30).std()
    zscore = (spread_series - rolling_mean) / rolling_std
    
    # Prepare response
    zscore_data = []
    for i, (date, z) in enumerate(zscore.items()):
        if not pd.isna(z):
            zscore_data.append({
                "date": date.strftime("%Y-%m-%d"),
                "zscore": float(z)
            })
    
    return jsonify({
        "pair": pair,
        "market": market,
        "hedge_ratio": float(hedge_ratio),
        "current_zscore": float(zscore.iloc[-1]) if not pd.isna(zscore.iloc[-1]) else 0,
        "data": zscore_data[-30:]  # Last 30 days
    })


@app.route('/api/circuit_breaker')
def get_circuit_breaker_status():
    """
    Get Circuit Breaker status.
    
    The Hybrid System:
    - Normal Market (VIX < 20): Gatekeeper OFF ‚Üí Maximize profit
    - Stress Market (VIX > 20 or crash): Gatekeeper ON ‚Üí Safety mode
    """
    if circuit_breaker is None:
        return jsonify({
            "available": False,
            "gatekeeper_enabled": GATEKEEPER_ENABLED,
            "status": "Circuit Breaker not loaded",
            "mode": "ALWAYS_ON" if GATEKEEPER_ENABLED else "ALWAYS_OFF"
        })
    
    status = circuit_breaker.check_conditions()
    
    return jsonify({
        "available": True,
        "gatekeeper_enabled": status['gatekeeper_enabled'],
        "market_status": status['market_status'],
        "triggers": status['triggers'],
        "details": status['details'],
        "mode": "HYBRID",
        "status_string": circuit_breaker.get_status_string()
    })


@app.route('/api/circuit_breaker/override', methods=['POST'])
def override_circuit_breaker():
    """Manually override Circuit Breaker (force Gatekeeper on/off)."""
    if circuit_breaker is None:
        return jsonify({"error": "Circuit Breaker not available"}), 400
    
    data = request.get_json() or {}
    action = data.get('action', 'auto')
    
    if action == 'on':
        circuit_breaker.force_gatekeeper(True)
        return jsonify({"status": "Gatekeeper forced ON"})
    elif action == 'off':
        circuit_breaker.force_gatekeeper(False)
        return jsonify({"status": "Gatekeeper forced OFF"})
    elif action == 'auto':
        circuit_breaker.reset_override()
        return jsonify({"status": "Gatekeeper reset to AUTO mode"})
    else:
        return jsonify({"error": "Invalid action. Use: on, off, auto"}), 400


# Start background updater
def start_background():
    thread = threading.Thread(target=background_updater, daemon=True)
    thread.start()
    print("üîÑ Background updater started")


# ============================================================
# AUTO-START FOR GUNICORN
# This runs when gunicorn imports the module (not just __main__)
# ============================================================
_background_started = False

def ensure_background_running():
    """Ensure background updater is running (works with gunicorn)."""
    global _background_started
    if not _background_started:
        _background_started = True
        print("üöÄ Initializing on first request...")
        # Do initial updates
        try:
            update_crypto()
            update_stocks()
        except Exception as e:
            print(f"‚ö†Ô∏è Initial update error: {e}")
        # Start background thread
        start_background()


@app.before_request
def before_first_request():
    """Start background updater on first HTTP request."""
    ensure_background_running()


if __name__ == '__main__':
    print("\n" + "="*60)
    print("üöÄ UNIFIED TRADING SIMULATOR")
    print("="*60)
    print(f"   Crypto Pairs: {len(CRYPTO_PAIRS)} (OLS Z-score)")
    print(f"   Stock Pairs: {len(STOCK_PAIRS)} (Kalman Filter)")
    print(f"   Initial Capital: ${INITIAL_CAPITAL:,} per market")
    if GATEKEEPER_ENABLED and gatekeeper is not None:
        print(f"   üß† Gatekeeper: ACTIVE (threshold={GATEKEEPER_THRESHOLD})")
    else:
        print(f"   ‚ö†Ô∏è Gatekeeper: DISABLED")
    print("="*60)
    
    # Initial updates
    update_crypto()
    update_stocks()
    
    # Start background updater
    start_background()
    
    # Run Flask
    port = int(os.environ.get('PORT', 5000))
    app.run(host='0.0.0.0', port=port, debug=False)

